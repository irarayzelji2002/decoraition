<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Next Generation</title>
	<style>
		.user_mask_canvas {
			position: relative;
			width: 512px;
			height: 512px;
		}

		.add_canvas,
		.remove_canvas,
		.sam_canvas,
		.init_image_preview {
			position: absolute !important;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
		}

		.sam_canvas {
			overflow: hidden;
		}

		.sam_canvas img {
			filter: drop-shadow(0px 1000px 0px rgba(117, 67, 255, 0.5));
			transform: translateY(-1000px);
		}

		/* Add z-index for layering */
		.add_canvas {
			z-index: 2;
			/* Initially on top in Add mode */
		}

		.remove_canvas {
			z-index: 1;
			/* Initially below Add canvas */
		}

		/* Class to disable interaction */
		.inactive-canvas {
			pointer-events: none;
			opacity: 0.6;
			/* To visually indicate it's inactive */
		}

		/* Display control classes */
		.display_none {
			display: none;
		}

		.display_block {
			display: block;
		}

		/* Error message styling */
		.err_msg {
			color: rgb(220, 53, 69);
		}
	</style>
</head>

<body>
	<h1>Next Image Generation Test</h1>

	<form id="generate_image_form" enctype="multipart/form-data">
		<!-- Prompt -->
		<label for="prompt">Prompt:</label>
		<span id="prompt_err" class="err_msg"></span><br />
		<input type="text" id="prompt" name="prompt" required /><br /><br />
		<!-- Number of Images -->
		<label for="number_of_images">Number of Images:</label>
		<span id="number_of_images_err" class="err_msg"></span><br />
		<input type="range" id="number_of_images" name="number_of_images" min="1" max="4" value="1"
			required><br /><br />
		<!-- Color Palette -->
		<label for="color_palette">Color Palette (comma-separated hex codes):</label><br />
		<input type="text" id="color_palette" name="color_palette" /><br /><br />
		<!-- Init Image -->
		<label for="init_image">Init Image:</label>
		<span id="init_image_err" class="err_msg"></span>
		<input type="file" id="init_image" name="init_image" accept="image/png, image/jpg, image/jpeg" /><br /><br />
		<!-- Style Reference -->
		<label for="style_reference">Style Reference:</label>
		<span id="style_reference_err" class="err_msg"></span>
		<input type="file" id="style_reference" name="style_reference"
			accept="image/png, image/jpg, image/jpeg" /><br /><br />
		<!-- Mask Prompt -->
		<label for="mask_prompt">Mask Prompt:</label>
		<span id="mask_prompt_err" class="err_msg"></span><br />
		<input type="text" id="mask_prompt" name="mask_prompt" required /><br />
		<!-- Generate Mask button -->
		<span id="mask_general_err" class="err_msg"></span><br />
		<button type="button" onclick="generateMask()">
			Generate Mask
		</button><br /><br />
		<!-- SAM Mask -->
		<label for="sam_mask">SAM mask:</label>
		<span id="sam_mask_err" class="err_msg"></span>
		<div id="sam_mask_preview"></div>

		<!-- Brush size, color, and opacity controls -->
		<br />
		<label for="canvas_mode">Canvas Mode: <span id="canvas_mode_desc">Add To SAM Mask</span></label>
		<input type="checkbox" id="canvas_mode" checked><br /><br />
		<div>
			<div>Refine Mask Option:</div>
			<div>
				<input type="radio" id="refine_option_0" name="refine_option" value="0" checked />
				<label for="mask_0">Add first then remove</label>
			</div>
			<div>
				<input type="radio" id="refine_option_1" name="refine_option" value="1" />
				<label for="mask_1">Remove first then add</label>
			</div>
		</div>
		<div id="add_to_sam">
			<h3>Add To SAM Mask Options</h3>
			<label for="selected_color">Selected Color:</label>
			<input type="color" id="selected_color" value="#00ff40">

			<label for="selected_opacity">Selected Opacity:</label>
			<input type="range" id="selected_opacity" min="0" max="1" step="0.1" value="0.5">

			<label for="brush_size">Brush Size:</label>
			<input type="range" id="brush_size" min="5" max="50" value="20">

			<label for="selected_brush_mode">Brush Mode: <span id="selected_brush_mode_desc">Draw</span></label>
			<input type="checkbox" id="selected_brush_mode" checked>

			<label for="mask_visibility">Mask Visibility:</label>
			<input type="checkbox" id="mask_visibility" checked>

			<button id="clear_canvas">Clear</button>
		</div>
		<div id="remove_from_sam" class="display_none">
			<h3>Remove From SAM Mask Options</h3>
			<label for="selected_color">Selected Color:</label>
			<input type="color" id="selected_color" value="#ff0000">

			<label for="selected_opacity">Selected Opacity:</label>
			<input type="range" id="selected_opacity" min="0" max="1" step="0.1" value="0.5">

			<label for="brush_size">Brush Size:</label>
			<input type="range" id="brush_size" min="5" max="50" value="20">

			<label for="selected_brush_mode">Brush Mode: <span id="selected_brush_mode_desc">Draw</span></label>
			<input type="checkbox" id="selected_brush_mode" checked>

			<label for="mask_visibility">Mask Visibility:</label>
			<input type="checkbox" id="mask_visibility" checked>

			<button id="clear_canvas">Clear</button>
		</div>
		<div id="is_sam">
			<h3>SAM Mask Options</h3>
			<label for="selected_color">Selected Color:</label>
			<input type="color" id="selected_color" value="#7543ff">

			<label for="selected_opacity">Selected Opacity:</label>
			<input type="range" id="selected_opacity" min="0" max="1" step="0.1" value="0.5">
		</div>
		<!-- Canvas for drawing -->
		<div id="user_mask_canvas" class="user_mask_canvas">
			<img src="" id="init_image_preview" class="init_image_preview"></img>
			<div id="sam_canvas" class="sam_canvas"></div>
			<canvas id="remove_canvas" class="remove_canvas"></canvas>
			<canvas id="add_canvas" class="add_canvas"></canvas>
		</div>
		<!-- Base64 Encoded Output -->
		<div id="get_user_mask_add">
			<label for="user_mask">User Mask (Add):</label>
			<span id="user_mask_err" class="err_msg"></span><br />
			<textarea id="user_mask_base64_output" name="user_mask" rows="3" cols="50"
				placeholder="Base 64 of User Mask"></textarea><br />
			<button type="button" id="get_user_mask">
				Get User Mask (Add)
			</button><br /><br />
		</div>
		<div id="get_user_mask_remove">
			<label for="user_mask">User Mask (Remove):</label>
			<span id="user_mask_err" class="err_msg"></span><br />
			<textarea id="user_mask_base64_output" name="user_mask" rows="3" cols="50"
				placeholder="Base 64 of User Mask"></textarea><br />
			<button type="button" id="get_user_mask">
				Get User Mask (Remove)
			</button><br /><br />
		</div>
		<button type="button" id="preview_mask">
			Preview Mask
		</button>
		<button type="button" id="apply_mask">
			Apply Mask
		</button>

		<!-- Generate button -->
		<span id="general_err" class="err_msg"></span><br />
		<button type="button" onclick="generateNextImage()">
			Generate
		</button>
	</form>

	<button onclick="document.location='/test/first-generation'">
		First Generation
	</button>

	<div id="image_container"></div>

	<script>
		window.sam_image_paths = {};
		window.selected_sam_mask = {};

		async function generateMask() {
			let err_count = 0;
			const err_msgs = document.querySelectorAll(".err_msg");
			for (let i = 0; i < err_msgs.length; i++) {
				err_msgs[i].innerHTML = "";
			}
			// Get form elements
			const mask_prompt = document.getElementById("mask_prompt").value.trim();
			const init_image = document.getElementById("init_image").files[0];

			// Validation
			if (!mask_prompt) {
				document.getElementById("mask_prompt_err").innerHTML = "Mask prompt is required to generate a mask.";
				err_count++;
			}
			if (!init_image) {
				document.getElementById("init_image_err").innerHTML = "Init image is required.";
				err_count++;
			}
			if (err_count > 0) {
				return;
			}

			// Create FormData object
			const formData = new FormData();
			formData.append("mask_prompt", mask_prompt);
			formData.append("init_image", init_image);

			// Fetch API
			try {
				const response = await fetch("/generate-sam-mask", {
					method: "POST",
					body: formData,
				});

				if (!response.ok) {
					document.getElementById("mask_general_err").innerHTML = "Failed to generate mask";
					throw new Error("Failed to generate SAM mask");
				}

				const data = await response.json();
				const sam_mask_preview = document.getElementById("sam_mask_preview");
				sam_mask_preview.innerHTML = "";
				const { blended_images, masks, masked_images } = data.image_paths;
				window.sam_image_paths = data.image_paths

				// Dynamically create a radio group for the 3 mask options
				blended_images.forEach((blended_image, index) => {
					const maskOption = document.createElement("div");
					maskOption.innerHTML = `
						<input type="radio" id="mask_${index}" name="selected_mask" value="${index}" ${index === 0 ? 'checked' : ''} />
						<label for="mask_${index}">
							<img src="${blended_images[index]}" alt="Blended Image" width="100" />
							<img src="${masks[index]}" alt="Mask Image" width="100" />
							<img src="${masked_images[index]}" alt="Masked Image" width="100" />
						</label>
					`;
					sam_mask_preview.appendChild(maskOption);

					// Add an event listener for this radio button
					const radio = maskOption.querySelector('input[name="selected_mask"]');
					console.log("inside foreach");
					radio.addEventListener('change', function () {
						const selectedMaskRadioChecked = document.querySelector('input[name="selected_mask"]:checked');
						const selectedIndex = selectedMaskRadioChecked.value;
						const { blended_images, masks, masked_images } = window.sam_image_paths;
						window.selected_sam_mask = {
							"blended_image": blended_images[selectedIndex],
							"mask": masks[selectedIndex],
							"masked_image": masked_images[selectedIndex]
						};
						console.log("1window.sam_image_paths:", window.sam_image_paths);
						console.log("1window.selected_sam_mask:", window.selected_sam_mask);
						window.useSelectedMask();
					});

					if (index == 0) {
						window.selected_sam_mask = {
							"blended_image": blended_images[0],
							"mask": masks[0],
							"masked_image": masked_images[0]
						};
						window.useSelectedMask();
					}
				});
			} catch (error) {
				console.error("Error:", error);
			}
		}

		async function generateNextImage() {
			let err_count = 0;
			const err_msgs = document.querySelectorAll(".err_msg");
			for (let i = 0; i < err_msgs.length; i++) {
				err_msgs[i].innerHTML = "";
			}
			// Get form elements
			const prompt = document.getElementById("prompt").value.trim();
			const number_of_images = document.getElementById("number_of_images").value.trim();
			const color_palette = document.getElementById("color_palette").value.trim();
			const init_image = document.getElementById("init_image").files[0];
			document.getElementById("get_user_mask").click()
			const user_mask = document.getElementById("user_mask_base64_output").value;
			const style_reference = document.getElementById("style_reference").files[0];
			const mask_prompt = document.getElementById("mask_prompt").value.trim();

			// Validation
			const selectedMaskRadio = document.querySelectorAll('input[name="selected_mask"]');
			if (selectedMaskRadio.length == 0) {
				if (!init_image && !mask_prompt) {
					document.getElementById("general_err").innerHTML = "Generate a mask first with the mask prompt and init image.";
					return;
				} else if (!mask_prompt || !init_image) {
					if (!mask_prompt) {
						document.getElementById("mask_prompt_err").innerHTML = "Mask prompt is required to generate a mask.";
					}
					if (!init_image) {
						document.getElementById("init_image_err").innerHTML = "Init image is required to generate a mask.";
					}
					return;
				} else {
					document.getElementById("general_err").innerHTML = "Generate a mask first.";
					return;
				}
			}
			if (!prompt) {
				document.getElementById("prompt_err").innerHTML = "Prompt is required.";
				err_count++;
			}
			if (!number_of_images || number_of_images < 1 || number_of_images > 4) {
				document.getElementById("number_of_images_err").innerHTML = "Please enter a valid number of images (1-4).";
				err_count++;
			}

			// Get selected mask index from radio buttons & corresponding mask data
			const selectedMaskRadioChecked = document.querySelector('input[name="selected_mask"]:checked');
			if (!selectedMaskRadioChecked) {
				document.getElementById("sam_mask_err").innerHTML = "Please select a SAM mask.";
				err_count++;
			}
			const selectedIndex = selectedMaskRadioChecked.value;
			const { blended_images, masks, masked_images } = window.sam_image_paths;
			const sam_mask = {
				"blended_image": blended_images[selectedIndex],
				"mask": masks[selectedIndex],
				"masked_image": masked_images[selectedIndex]
			};

			if (err_count > 0) {
				return;
			}

			// Create FormData object
			const formData = new FormData();
			formData.append("prompt", prompt);
			formData.append("number_of_images", number_of_images);
			if (color_palette) {
				const colorsArray = color_palette.split(",").map((color) => color.trim());
				formData.append("color_palette", JSON.stringify(colorsArray));
			}
			formData.append("init_image", init_image);
			formData.append("sam_mask", JSON.stringify(sam_mask));  // Append the sam_mask object
			if (user_mask) {
				formData.append("user_mask", user_mask);
			}
			if (style_reference) {
				formData.append("style_reference", style_reference);
			}
			console.log("Form Data:");
			console.log(formData);

			// Fetch API call to generate the next image
			try {
				const response = await fetch("/generate-next-image", {
					method: "POST",
					body: formData,
				});

				if (!response.ok) {
					document.getElementById("general_err").innerHTML = "Failed to generate image";
					throw new Error("Failed to generate image");
				}

				const data = await response.json();
				const imageContainer = document.getElementById("image_container");
				imageContainer.innerHTML = "";

				// Display generated images
				data.image_paths.forEach((path) => {
					const img = document.createElement("img");
					img.src = path;
					img.alt = "Generated Image";
					img.style.maxWidth = "100%";
					img.style.height = "auto";
					imageContainer.appendChild(img);
				});
			} catch (error) {
				console.error("Error:", error);
			}
		}
	</script>
	<script src="{{ url_for('static', filename='js/canvas_script.js') }}"></script>
</body>

</html>