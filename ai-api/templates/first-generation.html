<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>First Generation</title>
	<style>
		.err_msg {
			color: rgb(220, 53, 69);
		}
	</style>
</head>

<body>
	<h1>First Image Generation Test</h1>

	<form id="generate_image_form" method="POST" enctype="multipart/form-data">
		<!-- Prompt -->
		<label for="prompt">Prompt:</label>
		<span id="prompt_err" class="err_msg"></span><br />
		<input type="text" id="prompt" name="prompt" required /><br /><br />
		<!-- Number of Images -->
		<label for="number_of_images">Number of Images:</label>
		<span id="number_of_images_err" class="err_msg"></span><br />
		<input type="number" id="number_of_images" name="number_of_images" min="1" max="4" value="1"
			required /><br /><br />
		<!-- Color Palette -->
		<label for="color_palette">Color Palette (comma-separated hex codes):</label><br />
		<input type="text" id="color_palette" name="color_palette" /><br /><br />
		<!-- Base Image -->
		<label for="base_image">Base Image:</label>
		<span id="base_image_err" class="err_msg"></span>
		<input type="file" id="base_image" name="base_image" accept="image/png, image/jpg, image/jpeg" />
		<button type="button" onclick="removeUploadedFile('base_image')">
			Remove Base Image
		</button>
		<br /><br />
		<!-- Style Reference -->
		<label for="style_reference">Style Reference:</label>
		<span id="style_reference_err" class="err_msg"></span>
		<input type="file" id="style_reference" name="style_reference" accept="image/png, image/jpg, image/jpeg" />
		<button type="button" onclick="removeUploadedFile('style_reference')">
			Remove Style Reference
		</button>
		<br /><br />
		<!-- Generate button -->
		<span id="general_err" class="err_msg"></span><br />

		<button type="button" onclick="generateFirstImage()">
			Generate
		</button>
	</form>

	<button type="button" onclick="document.location='/test/next-generation'">
		Next Generation
	</button>

	<div>
		<span id=" status_message"></span><br />
		<div class="progress">
			<progress id="progress_bar" value="0" max="100"></progress><br />
			<span id="progress_message"></span><br />
			<span id="time_remaining_message"></span><br />
		</div>
		<div id="image_container"></div>
	</div>

	<script>
		document.addEventListener("DOMContentLoaded", function () {
			// Progress
			const progress_bar = document.getElementById('progress_bar');
			progress_bar.style.display = progress_bar.value != 0 ? "block" : "none";
		});

		// Function to remove uploaded file
		function removeUploadedFile(inputId) {
			const fileInput = document.getElementById(inputId);
			if (fileInput) {
				fileInput.value = "";
				console.log(`${inputId} has been cleared.`);
			} else {
				console.error(`Input element with id "${inputId}" not found.`);
			}
		}

		// Function when Generate is clicked
		async function generateFirstImage() {
			let err_count = 0;
			const err_msgs = document.querySelectorAll(".err_msg");
			for (let i = 0; i < err_msgs.length; i++) {
				err_msgs[i].innerHTML = "";
			}

			// Get form elements
			const prompt = document.getElementById("prompt").value.trim();
			const number_of_images = document.getElementById("number_of_images").value.trim();
			const color_palette = document.getElementById("color_palette").value.trim();
			const base_image = document.getElementById("base_image").files[0];
			const style_reference = document.getElementById("style_reference").files[0];

			// Validation
			if (!prompt) {
				document.getElementById("prompt_err").innerHTML = "Prompt is required.";
				err_count++;
			}
			if (!number_of_images || number_of_images < 1 || number_of_images > 4) {
				document.getElementById("number_of_images_err").innerHTML = "Please enter a valid number of images (1-4).";
				err_count++;
			}
			if (base_image) {
				const validExtensions = ["jpg", "jpeg", "png"];
				const fileExtension = base_image.name.split(".").pop().toLowerCase();

				if (!validExtensions.includes(fileExtension)) {
					document.getElementById("base_image_err").innerHTML = "Invalid file type. Please upload a JPG or PNG image.";
					err_count++;
				}
			}
			if (style_reference) {
				const validExtensions = ["jpg", "jpeg", "png"];
				const fileExtension = style_reference.name.split(".").pop().toLowerCase();

				if (!validExtensions.includes(fileExtension)) {
					document.getElementById("style_reference_err").innerHTML = "Invalid file type. Please upload a JPG or PNG image.";
					err_count++;

				}
			}
			if (err_count > 0) {
				return;
			}

			// Create FormData object
			const formData = new FormData();
			formData.append("prompt", prompt);
			formData.append("number_of_images", number_of_images);
			if (color_palette) {
				const colorsArray = color_palette.split(",").map((color) => color.trim());
				formData.append("color_palette", JSON.stringify(colorsArray));
			}
			if (base_image) {
				formData.append("base_image", base_image);
			}
			if (style_reference) {
				formData.append("style_reference", style_reference);
			}

			// Fetch API call to generate the first image
			try {
				const generateResponse = await fetch("/generate-first-image", {
					method: "POST",
					body: formData,
				});

				if (!generateResponse.ok) {
					document.getElementById("general_err").innerHTML = "Failed to queue task";
					throw new Error("Failed to queue task");
				}

				const generateData = await generateResponse.json();
				const taskId = generateData.task.task_id;
				console.log(`Task ID: ${taskId}`);
				let task = await checkTaskStatus(taskId);
			} catch (error) {
				console.error("Error:", error);
			}
		}

		// Function to check task status
		async function checkTaskStatus(taskId) {
			let running = false;
			console.log("Tracking Status: ")
			while (!running) {
				const response = await fetch(`/generate-image/task-status?task_id=${taskId}`);

				if (!response.ok) {
					const errorMessage = await response.json();
					throw new Error(errorMessage.error || "Failed to get task results");
				}

				const data = await response.json();

				if (data.position != 1) {
					document.getElementById("status_message").innerHTML = `Your task is in queue at position ${data.position}`;
					console.log(`Your task is in queue at position ${data.position}`);
				} else {
					running = true;
					document.getElementById("status_message").innerHTML = "Image generation in progress...";
					// Track progress until task is complete
					console.log("Tracking Image: ");
					await trackImageGenerationProgress(taskId);
					// Fetch and display the generated images
					console.log("Displaying Image: ");
					await displayGeneratedImages(taskId);
				}

				if (!running) {
					await new Promise(resolve => setTimeout(resolve, 100));
				}
			}
		}

		// Function to track progress of image generation
		async function trackImageGenerationProgress(taskId) {
			let progress = 0;
			let eta_relative = 0;
			let current_image = null;
			let previous_image = null;
			let completed = false;
			let status = "pending";

			while (!completed) {
				// Fetch API
				const response = await fetch(`/generate-image/image-status?task_id=${taskId}`);

				if (!response.ok) {
					const errorMessage = await response.json();
					throw new Error(errorMessage.error || "Failed to get progress.");
				}

				const data = await response.json();
				progress = data.progress;
				eta_relative = data.eta_relative;
				current_image = data.current_image;
				status = data.status;

				// Display progress and preview image if current_image is available
				if (progress != 0) {
					const progress_bar = document.getElementById('progress_bar');
					progress_bar.value = Math.round(progress * 100).toFixed(0);
					progress_bar.style.display = "block";
					document.getElementById("progress_message").innerHTML = `Progress: ${Math.round(progress * 100).toFixed(0)}%`;
					document.getElementById("time_remaining_message").innerHTML = `ETA: ${Math.round(eta_relative).toFixed(0)}s`;
					console.log(`Progress: ${Math.round(progress * 100).toFixed(0)}%; ETA: ${Math.round(eta_relative).toFixed(0)}s; Sampling Step: ${data.state.sampling_step}`);

					if (current_image != null && previous_image != current_image) {
						const imageContainer = document.getElementById("image_container");
						imageContainer.innerHTML = `
							<img src="data:image/png;base64,${data.current_image}" alt="Preview Image" style="max-width:100%; height:auto;">
						`;
						previous_image = current_image;
					}
				}

				// Mark the task as completed if `current_image` becomes null after being non-null & status is success/failed
				if (previous_image != null && current_image == null && (status === 'success' || status === 'failed')) {
					completed = true;
					console.log("Image generation completed.");
					progress_bar.style.display = "none";
					document.getElementById("status_message").innerHTML = "Image generation complete!";
					document.getElementById("progress_message").innerHTML = "";
					document.getElementById("time_remaining_message").innerHTML = "";
				}

				if (!completed) {
					await new Promise(resolve => setTimeout(resolve, 100));
				}
			}
		}

		// Function to fetch and display the generated images
		async function displayGeneratedImages(taskId) {
			const response = await fetch(`/generate-image/get-results?task_id=${taskId}`, {
				method: "GET"
			});

			if (!response.ok) {
				const errorMessage = await response.json();
				throw new Error(errorMessage.error || "Failed to get task results");
			}

			const data = await response.json();
			const imageContainer = document.getElementById("image_container");
			imageContainer.innerHTML = "";

			if (data && data.image_paths) {
				data.image_paths.forEach((path) => {
					const img = document.createElement("img");
					img.src = path;
					img.alt = "Generated Image";
					img.style.maxWidth = "100%";
					img.style.height = "auto";
					imageContainer.appendChild(img);
				});
			}
		}
	</script>
</body>

</html>